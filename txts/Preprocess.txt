#!/usr/bin/env python
# coding: utf-8
"""
========================================================================
Â© 2021 Institute for Clinical Evaluative Sciences. All rights reserved.

TERMS OF USE:
##Not for distribution.## This code and data is provided to the user solely for its own non-commercial use by individuals and/or not-for-profit corporations. User shall not distribute without express written permission from the Institute for Clinical Evaluative Sciences.

##Not-for-profit.## This code and data may not be used in connection with profit generating activities.

##No liability.## The Institute for Clinical Evaluative Sciences makes no warranty or representation regarding the fitness, quality or reliability of this code and data.

##No Support.## The Institute for Clinical Evaluative Sciences will not provide any technological, educational or informational support in connection with the use of this code and data.

##Warning.## By receiving this code and data, user accepts these terms, and uses the code and data, solely at its own risk.
========================================================================
"""
# In[1]:


import sys


# In[2]:


for i, p in enumerate(sys.path):
    sys.path[i] = sys.path[i].replace("/software/anaconda/3/", "/MY/PATH/.conda/envs/myenv/")


# In[3]:


import tqdm
import os
import itertools
import pandas as pd
import numpy as np
import multiprocessing as mp
import datetime as dt
import utilities as util
import matplotlib.pyplot as plt

from functools import partial
from collections import Counter


# In[4]:


import torch



# # y3

# In[ ]:


chunks = pd.read_sas('DATAPATH/y3.sas7bdat', chunksize=10**5)
for i, chunk in tqdm.tqdm(enumerate(chunks)):
    header = True if i == 0 else False
    # chunk.to_csv('data/y3.csv', header=header, mode='a')


# In[7]:


y3 = pd.read_csv('data/y3.csv')


# # systemic
# 
# all patients in systemic are in y3_ikn<br>

# In[65]:


def create_clean_regimen(df):
    df['regimen'] = df['cco_regimen'].astype(str)
    df['regimen'] = df['regimen'].str[2:-1]
    df.loc[df['regimen'].str.contains('NCT'), 'regimen'] = 'TRIALS'
    df['regimen'] = df['regimen'].str.replace("*", "")
    df['regimen'] = df['regimen'].str.replace(" ", "")
    df['regimen'] = df['regimen'].str.lower()
    return df


# In[ ]:


chunks = pd.read_sas('DATAPATH/systemic.sas7bdat', chunksize=10**5) # chunksize=10**5, i=148, 10:59
for i, chunk in tqdm.tqdm(enumerate(chunks)):
    # remove empty rows
    chunk = chunk[~chunk.iloc[:,1:].isnull().all(axis=1)]
    
    # create cleaned up regimen column
    chunk = create_clean_regimen(chunk.copy())
    
    # write to csv
    header = True if i == 0 else False
    # chunk.to_csv("data/systemic1.csv", header=header, mode='a')


# In[13]:


chunks = pd.read_csv('data/systemic1.csv', chunksize=10**6) # (chunksize=10**5, i=142, 00:32), (chunksize=10**6, i=14, 00:32)

for i, chunk in tqdm.tqdm(enumerate(chunks)):
    # remove first two characters "b'" and last character "'"
    chunk['ikn'] = chunk['ikn'].str[2:-1]
    
    # get all data for patient id = XXXXXXXXXX
    chunk = chunk[chunk['ikn'] == 'XXXXXXXXXX']
    break


# In[14]:


chunk


# In[7]:


regimen_count1 = Counter() # based on number of rows (inlcudes all the different drug counts)
regimen_count2 = Counter() # based on chemo sessions
regimen_count3 = {} # based on number of patients

chunks = pd.read_csv('data/systemic1.csv', chunksize=10**6) # (chunksize=10**5, i=142, 00:32), (chunksize=10**6, i=14, 00:32)
for i, chunk in tqdm.tqdm(enumerate(chunks)):
    # remove first two characters "b'" and last character "'"
    chunk['ikn'] = chunk['ikn'].str[2:-1]
    
    # update occurence of regiments based on number of rows
    regimen_count1 += Counter(dict(chunk['regimen'].value_counts()))
    
    # keep only target columns
    chunk = chunk[['ikn', 'regimen', 'visit_date']]
    chunk = chunk.drop_duplicates()
    # update occurence of regiments based on number of chemo regiments
    regimen_count2 += Counter(dict(chunk['regimen'].value_counts()))
    
    # update occurence of regiments based on number of patients
    for regimen, group in chunk.groupby('regimen'):
        if regimen not in regimen_count3:
            regimen_count3[regimen] = set(group['ikn'].unique())
        else:
            regimen_count3[regimen].update(group['ikn'].unique())

regimen_count3 = {regimen:len(ikns) for regimen, ikns in regimen_count3.items()}
regimen_count3 = sorted(regimen_count3.items(), key=lambda x: x[1], reverse=True)


# In[8]:


regimens, count = zip(*regimen_count1.most_common(n=20))
fig = plt.figure(figsize=(15, 5))
ax = fig.add_subplot(1,3,1)
plt.title('Top 20 chemo regimen occurence\n based on number of rows')
plt.bar(regimens, count)
plt.xticks(rotation=90)

regimens, count = zip(*regimen_count2.most_common(n=20))
ax = fig.add_subplot(1,3,2)
plt.title('Top 20 chemo regimen occurence\n based on number of chemo sessions')
plt.bar(regimens, count)
plt.xticks(rotation=90)

regimens, count = zip(*regimen_count3[0:20])
ax = fig.add_subplot(1,3,3)
plt.title('Top 20 chemo regimen occurence\n based on number of patients')
plt.bar(regimens, count)
plt.xticks(rotation=90)

plt.show()


# # olis
# number of data points = xxx,xxx,xxx<br>
# earliest date = xxxx-xx-xx xx:xx:xx<br>
# latest date = xxxx-xx-xx xx:xx:xx
# 
# Note: I think they made a mistake. value_recommended_d is the value of the test result (variable should be named "value")

# In[ ]:


chunks = pd.read_sas('DATAPATH/olis.sas7bdat', chunksize=10**5) # chunksize=10**5, i=1868, 36:13
for i, chunk in tqdm.tqdm(enumerate(chunks)):
    # remove empty rows
    chunk = chunk[~chunk.iloc[:,1:].isnull().all(axis=1)]
    
    # keep only ObservationCode 777-3 (PLATELETS), 751-8 (NEUTROPHIL), 718-7 (HEMOGLOBIN)
    chunk = chunk[chunk['ObservationCode'].isin([b'777-3',b'751-8',b'718-7'])]
    
    # write to csv
    header = True if i == 0 else False
    # chunk.to_csv("data/olis1.csv", header=header, mode='a')


# In[12]:


chunks = pd.read_csv("data/olis1.csv", chunksize=10**6) # (chunksize=10**5, i=653, 01:45), (chunksize=10**6, i=66, 1:45)

tmp = pd.DataFrame()

for i, chunk in tqdm.tqdm(enumerate(chunks)):
    # remove first two characters "b'" and last character "'"
    chunk['ikn'] = chunk['ikn'].str[2:-1]
    
    # get all data where patient id = X
    tmp = pd.concat([tmp, chunk[chunk['ikn'] == 'X']])
    break


# In[13]:


tmp


# # Selected Regimens

# In[7]:


df = util.read_partially_reviewed_csv()
df = util.get_included_regimen(df)


# In[8]:


# patient count plot
plt.plot(df['patient_count'].astype(int))
plt.xticks(rotation=90)
plt.title('Selected chemo regiments and their number of patients')
plt.show()


# In[9]:


regimen_name_mapping = df['mapping_to_proper_name'].to_dict()
regimen_name_mapping = {mapped_from: mapped_to if mapped_to != 'None' else mapped_from 
                        for mapped_from, mapped_to in regimen_name_mapping.items()}
cycle_lengths = df['cycle_length'].to_dict()


# In[10]:


regiments = df.index 
print(f'len(regiments) will show {len(regiments)} when it should be 33, the papaclicarbo will be renamed to crbppacl, thus we will end up with 33 regiments')


# # Create my csv

# In[11]:


din_exclude = ['02441489', '02454548', '01968017', '02485575', '02485583', '02485656', '02485591',
               '02484153', '02474565', '02249790', '02506238', '02497395'] # for neutrophil

y3_cols = ['ikn', 'sex', 'bdate',
           'lhin_cd', # local health integration network
           'curr_morph_cd', # cancer type
           'curr_topog_cd', # cancer location
          ] #pstlcode

systemic_cols = ['ikn', 'regimen', 'visit_date', 
                 'body_surface_area',#m^2
                 'intent_of_systemic_treatment', # A - after surgery, C - chemo, N - before surgery, P - incurable
                 'line_of_therapy', # switch from one regimen to another
                ] 
                # 'din', 'cco_drug_code', 'dose_administered', 'measurement_unit']
    
olis_cols = ['ikn', 'ObservationCode', 'ObservationDateTime', 'ObservationReleaseTS', 'value_recommended_d']


# In[12]:


def filter_data(chunk):
    # remove first two characters "b'" and last character "'"
    for col in ['ikn', 'din']:
        chunk[col] = chunk[col].str[2:-1]
    
    # keep only selected reigments
    chunk = chunk[chunk['regimen'].isin(regiments)]
    
    # remove dins in din_exclude
    chunk = chunk[~chunk['din'].isin(din_exclude)]
    
    # keep only selected columns
    chunk = chunk[systemic_cols]
    chunk = chunk.drop_duplicates()
    
    return chunk


# In[13]:


ikn_chemo_dict = {}
chunks = pd.read_csv('data/systemic1.csv', chunksize=10**6) # (chunksize=10**5, i=142, 00:32), (chunksize=10**6, i=14, 00:32)
for i, chunk in tqdm.tqdm(enumerate(chunks), total=14):
    chunk = filter_data(chunk)
    
    # combine all patients from all the chunks
    for ikn, group in chunk.groupby('ikn'):
        if ikn in ikn_chemo_dict:
            ikn_chemo_dict[ikn] = pd.concat([ikn_chemo_dict[ikn], group])
        else:
            ikn_chemo_dict[ikn] = group


# In[14]:


print("Number of patients =", len(ikn_chemo_dict.keys()))


# In[15]:


def merge_intervals(df):
    # Merges small intervals into a 4 day cycle, or to the row below/above that has interval greater than 4 days
    df = df.reset_index(drop=True)
    remove_indices = []
    for i in range(len(df)):
        if df.loc[i, 'chemo_interval'] > pd.Timedelta('3 days') or pd.isnull(df.loc[i, 'chemo_interval']):
            continue
        if i == len(df)-1:
            # merge with the row above if last entry of a regimen
            if i == 0: # if its the very first entry of the whole dataframe, leave it as is
                continue 
            df.loc[i-1, 'visit_date'] = df.loc[i, 'visit_date']
            df.loc[i-1, 'chemo_interval'] = df.loc[i, 'chemo_interval'] + df.loc[i-1, 'chemo_interval'] 
        elif df.loc[i, 'regimen'] != df.loc[i+1, 'regimen']:
            # merge with the row above if last entry of an old regimen
            if i == 0: # if its the very first entry of the whole dataframe, leave it as is
                continue 
            df.loc[i-1, 'visit_date'] = df.loc[i, 'visit_date']
            df.loc[i-1, 'chemo_interval'] = df.loc[i, 'chemo_interval'] + df.loc[i-1, 'chemo_interval'] 
        else:
            # merge with the row below
            df.loc[i+1, 'prev_visit'] = df.loc[i, 'prev_visit']
            df.loc[i+1, 'chemo_interval'] = df.loc[i, 'chemo_interval'] + df.loc[i+1, 'chemo_interval']
        remove_indices.append(i)
    df = df.drop(index=remove_indices)
    return df 


# In[16]:


chemo = []
num_chemo_sess_elimniated = 0
for ikn, df in tqdm.tqdm(ikn_chemo_dict.items()):
    # change regimen name to the correct mapping
    df['regimen'] = df['regimen'].map(regimen_name_mapping)
    
    # order the dataframe by date
    df = df.drop_duplicates()
    df['visit_date'] = pd.to_datetime(df['visit_date'])
    df = df.sort_values(by='visit_date')
    
    # include prev visit and chemo interval
    df['prev_visit'] = df['visit_date'].shift()
    df.loc[~df['regimen'].eq(df['regimen'].shift()), 'prev_visit'] = pd.NaT # break off when chemo regimen changes
    df['chemo_interval'] = df['visit_date'] - df['prev_visit']
    
    # Merges small intervals into a 4 day cycle, or to the row below/above that has interval greater than 4 days
    # NOTE: for patient X (same with Y), they have single chemo sessions that gets eliminated. 
    num_chemo_sess_elimniated += len(df[df['prev_visit'].isnull() & ~df['regimen'].eq(df['regimen'].shift(-1))])
    df = df[~df['chemo_interval'].isnull()]
    if df.empty:
        ikn_chemo_dict[ikn] = df
        continue
    df = merge_intervals(df)
    if df.empty:
        # most likely patient (e.g. Z) had consecutive 1 day interval chemo sessions 
        # that totaled less than 5 days
        ikn_chemo_dict[ikn] = df
        continue
    
    # identify chemo cycle number (resets when patient undergoes new chemo regimen or there is a 60 day gap)
    mask = df['regimen'].eq(df['regimen'].shift()) & (df['chemo_interval'].shift() < pd.Timedelta('60 days'))
    group = (mask==False).cumsum()
    df['chemo_cycle'] = mask.groupby(group).cumsum()+1
    
    # identify if this is the first chemo cycle of a new regimen immediately after the old one
    # WARNING: currently does not account for those single chemo sessios (that gets eliminated above )
    mask = ~df['regimen'].eq(df['regimen'].shift()) &             (df['prev_visit']-df['visit_date'].shift() < pd.Timedelta('60 days'))
    mask.iloc[0] = False
    df['immediate_new_regimen'] = mask
    
    # convert to list and combine for faster performance
    chemo.extend(df.values.tolist())
    
chemo_df = pd.DataFrame(chemo, columns=df.columns)


# In[17]:


print("Number of single chemo sessions eliminated =", num_chemo_sess_elimniated)


# In[18]:


# include features from y3 dataset
y3 = pd.read_csv('data/y3.csv')
y3 = y3[y3_cols]
y3['ikn'] = y3['ikn'].str[2:-1]
y3 = y3.set_index('ikn')
chemo_df = chemo_df.join(y3, on='ikn')
chemo_df['bdate'] = pd.to_datetime(chemo_df['bdate'])
chemo_df['age'] = chemo_df['prev_visit'].dt.year - chemo_df['bdate'].dt.year


# In[19]:


# clean up some features
chemo_df['body_surface_area'] = chemo_df['body_surface_area'].replace(0, np.nan)
chemo_df['body_surface_area'] = chemo_df['body_surface_area'].replace(-99, np.nan)
chemo_df['curr_morph_cd'] = chemo_df['curr_morph_cd'].replace('*U*', np.nan)
# remove first two characters "b'" and last character "'"
for col in ['intent_of_systemic_treatment', 'lhin_cd', 'curr_morph_cd', 'curr_topog_cd', 'sex']:
    chemo_df[col] = chemo_df[col].str[2:-1]
# clean up morphology and topography code features
for col in ['curr_morph_cd', 'curr_topog_cd']:
    chemo_df[col] = chemo_df[col].replace('*U*', np.nan)
    # replace code with number of rows less than 6 to 'Other'
    counts = chemo_df[col].value_counts() 
    replace_code = counts.index[counts < 6]
    chemo_df.loc[chemo_df[col].isin(replace_code), col] = 'Other'


# In[20]:


# rearrange the columns
chemo_df = chemo_df[['ikn', 'regimen', 'visit_date', 'prev_visit', 'chemo_interval', 'chemo_cycle', 'immediate_new_regimen',
        'intent_of_systemic_treatment', 'line_of_therapy', 'lhin_cd', 'curr_morph_cd', 'curr_topog_cd',
        'age', 'sex', 'body_surface_area']]


# In[21]:


chemo_df.to_csv('data/chemo_processed.csv', index=False)


# In[13]:


chemo_df = pd.read_csv('data/chemo_processed.csv', dtype={'ikn': str})
chemo_df['visit_date'] = pd.to_datetime(chemo_df['visit_date'])
chemo_df['prev_visit'] = pd.to_datetime(chemo_df['prev_visit'])
chemo_df['chemo_interval'] = pd.to_timedelta(chemo_df['chemo_interval'])


# In[16]:


print("Number of rows now", len(chemo_df))
print("Number of patients now =", len(chemo_df['ikn'].unique()))
print("Number of rows with chemo intervals less than 4 days =",# some still remained after merging of the intervals
      len(chemo_df[chemo_df['chemo_interval'] < pd.Timedelta('4 days')]))


# In[17]:


# create columns for 5 days before to 28 days after chemo administration
df = chemo_df.copy()
df.loc[:, range(-5, 29, 1)] = np.nan
neutrophil_df = df.copy()
platelet_df = df.copy()
hemoglobin_df = df.copy()
mapping = {'777-3': platelet_df, '751-8': neutrophil_df, '718-7': hemoglobin_df}
del df
neutrophil_df.head()


# ### Multiprocessing
# Parallelization Pipeline:<br>
# for each chunk of olis data<br>
# we split the chemo data into partitions<br>
# each partition will be fed into a process worker<br>
# each worker will iterate through each row of the partition<br>
# for each row, we check if blood count data exist between the two target dates<br>
# if it exists, we place a tuple (blood type, chemo_df row index, column number, blood count value) onto a shared list between all processes<br>
# In the end, we loop through the shared list and update the neutrophil/platelet/hemoglobin dataframes
#     

# In[16]:


processes = 32 # 16 - 1.5 hours, 32 - 50 min, 64 - 50 min   <-- srun -p high -c 32 --mem=96G --pty bash
 
# Manager to create a shared object
manager = mp.Manager()

# create global objects
shared_dict = manager.dict()

def worker(partition):
    chunk = shared_dict['olis_chunk']
    result = []
    # loop through each row of this partition
    for chemo_idx, chemo_row in tqdm.tqdm(partition.iterrows(), total=len(partition), position=0):
        
        # see if there any blood count data within the target dates
        earliest_date = chemo_row['prev_visit'] - pd.Timedelta('5 days')
        # set limit to 28 days after chemo administration or the day of next chemo administration, 
        # whichever comes first
        latest_date = min(chemo_row['visit_date'], chemo_row['prev_visit'] + pd.Timedelta('28 days'))
        tmp = chunk[(earliest_date < chunk['ObservationDateTime']) & 
                    (chunk['ObservationDateTime'] < latest_date) & 
                    (chunk['ikn'] == chemo_row['ikn'])]
        
        # loop through the blood count data
        for blood_idx, blood_row in tmp.iterrows():
            days_after_chemo = (blood_row['ObservationDateTime'] - chemo_row['prev_visit']).days

            # place onto result
            result.append((blood_row['ObservationCode'], chemo_idx, days_after_chemo, 
                           blood_row['value_recommended_d']))
    return result


# In[17]:


def filter_rows(chunk):
    # only keep rows where patient ids exist in both the olis chunk and chemo_df
    filtered_chemo_df = chemo_df[chemo_df['ikn'].isin(chunk['ikn'])]
    chunk = chunk[chunk['ikn'].isin(filtered_chemo_df['ikn'])]
    
    # remove rows with blood count null values
    chunk = chunk[~chunk['value_recommended_d'].isnull()]
    
    # remove duplicate rows
    subset = ['ikn','ObservationCode', 'ObservationDateTime', 'value_recommended_d']
    chunk = chunk.drop_duplicates(subset=subset) 
    
    # if only the patient id, blood, and observation timestamp are duplicated (NOT the blood count value), 
    # keep the most recently RELEASED row
    chunk = chunk.sort_values(by='ObservationReleaseTS')
    subset = ['ikn','ObservationCode', 'ObservationDateTime']
    chunk = chunk.drop_duplicates(subset=subset, keep='last')
    
    return filtered_chemo_df, chunk


# In[18]:


chunks = pd.read_csv("data/olis1.csv", chunksize=10**6) # (chunksize=10**5, i=653, 01:45), (chunksize=10**6, i=66, 1:45)
result = np.load('data/checkpoint/data_list_chunk15.npy').tolist()
for i, chunk in tqdm.tqdm(enumerate(chunks), total=66):
    if i < 16: continue
        
    # remove first two characters "b'" and last character "'"
    for col in ['ikn', 'ObservationCode']:
        chunk[col] = chunk[col].str[2:-1]
        
    # keep only selected columns
    chunk = chunk[olis_cols]
    
    # convert string column into timestamp column
    chunk['ObservationDateTime'] = pd.to_datetime(chunk['ObservationDateTime'])
    chunk['ObservationDateTime'] = chunk['ObservationDateTime'].dt.floor('D') # keep only the date, not time
    chunk['ObservationReleaseTS'] = pd.to_datetime(chunk['ObservationReleaseTS'])
    
    # filter out rows
    filtered_chemo_df, chunk = filter_rows(chunk)
    
    # find blood count values corresponding to each row in df concurrently in parallel processes
    shared_dict['olis_chunk'] = chunk
    # splits df into x number of partitions, where x is number of processes
    generator = np.array_split(filtered_chemo_df, processes)
    pool = mp.Pool(processes=processes)
    chunk_result = pool.map(worker, generator) # map each item in generator to worker function
    pool.close()
    pool.join() # wait for all threads
    
    chunk_result = list(itertools.chain(*chunk_result))
    result += chunk_result
    if i != 0:
        os.remove(f'data/checkpoint/data_list_chunk{i-1}.npy')
    print(f'OLIS chunk {i} completed: size of list', len(result))
    np.save(f"data/checkpoint/data_list_chunk{i}.npy", result)
np.save("data/data_list.npy", result)


# In[20]:


data_list = np.load('data/data_list.npy') # OHH I think it converts all the ints to string to save space
tmp = pd.DataFrame(data_list)
tmp = tmp[tmp.duplicated(keep=False)]
print("Not sure where these duplicates come from but\nlength of duplicates =", len(tmp))


# In[21]:


# update the neturophil/hemoglobin/platelet dataframes 
df = pd.DataFrame(data_list, columns=['blood_type', 'chemo_idx', 'days_after_chemo', 'blood_count'])
for blood_type, blood_group in df.groupby('blood_type'):
    for day, day_group in blood_group.groupby('days_after_chemo'):
        # print(f'Blood Type: {blood_type}, Days After Chemo: {day}, Number of Blood Samples: {len(day_group)}')
        chemo_indices = day_group['chemo_idx'].values.astype(int)
        blood_count_values = day_group['blood_count'].values.astype(float)
        mapping[blood_type].loc[chemo_indices, int(day)] = blood_count_values


# In[23]:


neutrophil_df.to_csv('data/neutrophil.csv',index=False)
platelet_df.to_csv('data/platelet.csv',index=False)
hemoglobin_df.to_csv('data/hemoglobin.csv',index=False)


# In[24]:


platelet_df.head()


# ### Gaussian playground

# In[19]:


X = np.atleast_2d([1, 3, 5, 6, 7, 8]).T
f = lambda x: x*np.sin(x)
y = f(X).ravel()


# In[20]:


from sklearn.gaussian_process import GaussianProcessRegressor
from sklearn.gaussian_process.kernels import RBF, ConstantKernel as C
from matplotlib import pyplot as plt


# In[21]:


kernel = C(1, (1e-3, 1e3)) * RBF(10, (1e-2, 1e2))


# In[22]:


gp = GaussianProcessRegressor(kernel=kernel, n_restarts_optimizer=9)


# In[23]:


gp.fit(X, y)


# In[24]:


x = np.atleast_2d(np.linspace(0, 10, 1000)).T
y_pred, sigma = gp.predict(x, return_std=True)


# In[25]:


plt.figure()
plt.plot(x, f(x), 'r:', label='f(x) = x*sin(x)')
plt.plot(X, y, 'r.', markersize=10,label='Observations')
plt.plot(x, y_pred, 'b-', label='Prediction')
plt.fill(np.concatenate([x, x[::-1]]),
         np.concatenate([y_pred - 1.96*sigma, (y_pred + 1.96*sigma)[::-1]]),
         alpha=0.5, fc='b', ec='None', label="95% confidence interval"
         )
plt.legend()


# # Scratch Notes
# ### Blood Playground - Parallelization Unraveled

# In[ ]:


# ETA: 8 Hours

mapping = {'777-3': platelet_df, '751-8': neutrophil_df, '718-7': hemoglobin_df}

chunks = pd.read_csv("data/olis1.csv", chunksize=10**6) # (chunksize=10**5, i=653, 01:45), (chunksize=10**6, i=66, 1:45)
for i, chunk in tqdm.tqdm(enumerate(chunks), total=66):
    
    # remove first two characters "b'" and last character "'"
    for col in ['ikn', 'ObservationCode']:
        chunk[col] = chunk[col].str[2:-1]
    
    # keep only selected columns
    chunk = chunk[olis_cols]
    
    # convert string column into timestamp column
    chunk['ObservationDateTime'] = pd.to_datetime(chunk['ObservationDateTime'])
    chunk['ObservationDateTime'] = chunk['ObservationDateTime'].dt.floor('D') # keep only the date, not time
    chunk['ObservationReleaseTS'] = pd.to_datetime(chunk['ObservationReleaseTS'])
    
    # filter out rows
    df = chemo_df[chemo_df['ikn'].isin(chunk['ikn'])] # only keep rows where patient ids are in the olis chunk
    chunk = chunk[chunk['ikn'].isin(df['ikn'])] # only keep rows where patient ids are in the filtered chemo_df
    chunk = chunk[~chunk['value_recommended_d'].isnull()] # remove rows with blood count null values
    subset = ['ikn','ObservationCode', 'ObservationDateTime', 'value_recommended_d']
    chunk = chunk.drop_duplicates(subset=subset) # remove duplicate rows
    # if only the patient id, blood, and observation timestamp are duplicated (NOT the blood count value), 
    # keep the most recently RELEASED row
    chunk = chunk.sort_values(by='ObservationReleaseTS')
    subset = ['ikn','ObservationCode', 'ObservationDateTime']
    chunk = chunk.drop_duplicates(subset=subset, keep='last')
    
    # loop through each row of this df
    for chemo_idx, chemo_row in tqdm.tqdm(df.iterrows(), total=len(df), position=0):
        
        # see if there any blood count data within the target dates
        earliest_date = chemo_row['prev_visit'] - pd.Timedelta('5 days')
        
        # set limit to 28 days after chemo administration or the day of next chemo administration, whichever comes first
        latest_date = min(chemo_row['visit_date'], chemo_row['prev_visit'] + pd.Timedelta('28 days'))
        tmp = chunk[(earliest_date < chunk['ObservationDateTime']) & 
                    (chunk['ObservationDateTime'] < latest_date) & 
                    (chunk['ikn'] == chemo_row['ikn'])]
        
        # loop through the blood count data
        for blood_idx, blood_row in tmp.iterrows():
            days_after_chemo = (blood_row['ObservationDateTime'] - chemo_row['prev_visit']).days

            # update the neutrophil/hemoglobin/platelet dataframes
            mapping[blood_row['ObservationCode']].loc[chemo_idx, days_after_chemo] = blood_row['value_recommended_d']


# hemoglobin - g/L<br>
# neutrophil - 10^9/L<br>
# platelet - 10^9/L

# ### Chemo playground

# #### regiments

# In[8]:


regimen_count = {}
chunks = pd.read_csv('data/systemic1.csv', chunksize=10**6) # (chunksize=10**5, i=142, 00:32), (chunksize=10**6, i=14, 00:32)
for i, chunk in tqdm.tqdm(enumerate(chunks)):
    # remove first two characters "b'" and last character "'"
    chunk['ikn'] = chunk['ikn'].str[2:-1]
    
    # update occurence of regiments based on number of patients
    for regimen, group in chunk.groupby('regimen'):
        if regimen not in regimen_count:
            regimen_count[regimen] = set(group['ikn'].unique())
        else:
            regimen_count[regimen].update(group['ikn'].unique())

regimen_count = {regimen:len(ikns) for regimen, ikns in regimen_count.items()}
regimen_count = sorted(regimen_count.items(), key=lambda x: x[1], reverse=True)


# In[18]:


df = pd.DataFrame(regimen_count, columns=['regiments', 'patient_count'])
df = df.set_index('regiments')
df['mapping_to_proper_name'] = 'None'
df['include (1) or exclude (0)'] = 0 # 
df.to_csv('regiments.csv')


# In[70]:


def read_partially_reviewed_csv():
    # df = pd.read_csv('/dshroot/share/rogrant/regimens_partial_review.csv')
    df = open('/dshroot/share/rogrant/regimens_partial_review.csv') # rob_grant_regiments.csv
    cols = next(df)
    cols = cols.strip().split(',')
    values = []
    for line in df:
        # make sure each line has correct number of entries
        line = line.strip().replace(',,', ',').split(',')
        if len(line) < len(cols): line.append('')
        if len(line) < len(cols): line.append('')
        if len(line) > len(cols): 
            new_note = ('').join(line[len(cols)-1:])
            line = line[:len(cols)-1]
            line.append(new_note)
        values.append(line)
    return pd.DataFrame(values, columns=cols)


# In[112]:


def get_included_regimen(df):
    df = df[df['include (1) or exclude (0)']=='1'] 
    df = df.drop(columns=['include (1) or exclude (0)'])
    df = df.set_index('regiments')
    return df


# In[114]:


df = read_partially_reviewed_csv()
df = get_included_regimen(df)
df


# #### drugs

# In[9]:


# Map all unique regiment drugs to the regimen
regimen_drug_mapping = {reg: {'din': set(), 'cco_drug_code': set()} for reg in regiments}

# Map cco_drug_code to din
din_drug_code_mapping = {}

num_of_cco_drug_codes = 0
num_of_dins = 0
unique_drug_codes = set()
unique_dins = set()
num_of_no_drug_info = 0
num_of_drug_codes_with_no_dins = 0
num_of_dins_with_no_drug_codes = 0

chunks = pd.read_csv('data/systemic1.csv', chunksize=10**6) # (chunksize=10**5, i=142, 00:32), (chunksize=10**6, i=14, 00:32)
for i, chunk in tqdm.tqdm(enumerate(chunks), total=14):
    # remove first two characters "b'" and last character "'"
    for col in ['cco_regimen', 'ikn', 'din', 'cco_drug_code']:
        chunk[col] = chunk[col].str[2:-1]
    
    # keep only chemo regimen *FOLFIRI+BEVA, *MFOLFOX6, *CRBPPACL, *CHOP+R, *AC-PACL(DD)
    chunk = chunk[chunk['cco_regimen'].isin(regiments)]
    
    # remove dins in din_exclude
    chunk = chunk[~chunk['din'].isin(din_exclude)]
    
    # map drugs to corresponding regimen
    for reg, group in chunk.groupby('cco_regimen'):
        tmp = group[~group['din'].isnull()]
        regimen_drug_mapping[reg]['din'].update(tmp['din'].unique())
        tmp = group[~group['cco_drug_code'].isnull()]
        regimen_drug_mapping[reg]['cco_drug_code'].update(tmp['cco_drug_code'].unique())
    
    # compute number of drugs
    num_of_cco_drug_codes += len(chunk[~chunk['cco_drug_code'].isnull()])
    num_of_dins += len(chunk[~chunk['din'].isnull()]) 
    unique_drug_codes.update(chunk['cco_drug_code'].unique())
    unique_dins.update(chunk['din'].unique()) 
    num_of_no_drug_info += len(chunk[chunk['din'].isnull() & chunk['cco_drug_code'].isnull()])
    num_of_drug_codes_with_no_dins += len(chunk[chunk['din'].isnull() & ~chunk['cco_drug_code'].isnull()])
    num_of_dins_with_no_drug_codes += len(chunk[~chunk['din'].isnull() & chunk['cco_drug_code'].isnull()])
    
    # map cco drug codes to din (one to many relationship)
    # NOTE it won't capture all the mappings
    tmp = chunk[~chunk['cco_drug_code'].isnull() & ~chunk['din'].isnull()]
    tmp = tmp[['cco_drug_code', 'din']]
    tmp = tmp.drop_duplicates()
    tmp = {din: set(group['cco_drug_code'].tolist()) for din, group in tmp.groupby('din')}
    for key, values in tmp.items():
        if key in din_drug_code_mapping:
            din_drug_code_mapping[key].update(values)
        else:
            din_drug_code_mapping[key] = values


# In[10]:


print('num of rows with cco_drug_codes', num_of_cco_drug_codes)
print('num of rows with dins', num_of_dins)
print('num of rows with no drug info', num_of_no_drug_info)
print('num of rows with cco_drug_codes and no dins', num_of_drug_codes_with_no_dins)
print('num of rows with dins and no cco_drug_codes', num_of_dins_with_no_drug_codes)
print('num of unique cco_drug_codes', len(unique_drug_codes))
print('num of unique dins', len(unique_dins))
print('num of dins mapped to cco_drug_codes', len(din_drug_code_mapping.keys()))
num_drugs_per_regimen = {}
for reg, values in regimen_drug_mapping.items():
    num_drugs_per_regimen[reg] = {}
    num_drugs_per_regimen[reg]['unique dins'] = len(values['din'])
    num_drugs_per_regimen[reg]['unique cco_drug_codes'] = len(values['cco_drug_code'])
pd.DataFrame(num_drugs_per_regimen).T


# **Merge din into cco_drug_code**

# In[11]:


# Map all unique regiment drugs to the regimen
regimen_drug_mapping = {reg: set() for reg in regiments}

unique_drugs = set()

num_samples_per_drug = {}

chunks = pd.read_csv('data/systemic1.csv', chunksize=10**6) # (chunksize=10**5, i=142, 00:32), (chunksize=10**6, i=14, 00:32)
for i, chunk in tqdm.tqdm(enumerate(chunks), total=14):
    # remove first two characters "b'" and last character "'"
    for col in ['cco_regimen', 'ikn', 'din', 'cco_drug_code']:
        chunk[col] = chunk[col].str[2:-1]
    
    # keep only chemo regimen *FOLFIRI+BEVA, *MFOLFOX6, *CRBPPACL, *CHOP+R, *AC-PACL(DD)
    chunk = chunk[chunk['cco_regimen'].isin(regiments)]
    
    # remove dins in din_exclude
    chunk = chunk[~chunk['din'].isin(din_exclude)]
    
    # remove rows with no drug information
    chunk = chunk[~(chunk['din'].isnull() & chunk['cco_drug_code'].isnull())]
    
    # merge din into drug code when no drug code is provided and din is not mapped to a drug code
    mask1 = chunk['cco_drug_code'].isnull()
    mask2 = chunk['din'].isin(din_drug_code_mapping)
    # get corresponding drug code from the mapping
    chunk.loc[mask1 & mask2, 'cco_drug_code'] = [list(din_drug_code_mapping[din])[0] 
                                                 for din in chunk.loc[mask1 & mask2, 'din']]
    # merge the din with no mapping
    chunk.loc[mask1 & ~mask2, 'cco_drug_code'] = chunk.loc[mask1 & ~mask2, 'din'].values
    chunk = chunk.drop('din', axis=1)
    
    # map drugs to corresponding regimen
    for reg, group in chunk.groupby('cco_regimen'):
        regimen_drug_mapping[reg].update(group['cco_drug_code'].unique())
    
    # compute unique drugs
    unique_drugs.update(chunk['cco_drug_code'].unique())
    
    # update number of rows/samples/examples per drug
    for drug, group in chunk.groupby('cco_drug_code'):
        if drug in num_samples_per_drug:
            num_samples_per_drug[drug] += len(group)
        else:
            num_samples_per_drug[drug] = len(group)


# In[12]:


print('num of unique drugs', len(unique_drugs))
num_drugs_per_regimen = {}
for reg, values in regimen_drug_mapping.items():
    num_drugs_per_regimen[reg] = {}
    num_drugs_per_regimen[reg]['unique drugs'] = len(values)
pd.DataFrame(num_drugs_per_regimen).T


# In[13]:


num_samples_per_drug


# In[19]:


freq_drugs = [(drug, num_samples) for drug, num_samples in num_samples_per_drug.items() if num_samples > 10000]
print('number of drugs with over 10000 samples =',len(freq_drugs))
freq_drugs


# #### merging cycles

# In[299]:


regiment_freq = {'*FOLFIRI+BEVA': pd.Timedelta('14 days'),
                 '*MFOLFOX6': pd.Timedelta('14 days'),
                 '*CRBPPACL': pd.Timedelta('21 days'),
                 '*CHOP+R': pd.Timedelta('21 days'),
                 '*BEND+RITU': pd.Timedelta('28 days'),
                 '*PACL(W)': pd.Timedelta('7 days'),
                 '*FOLFOX': pd.Timedelta('14 days'),
                 '*ABVD': pd.Timedelta('14 days'),
                 '*AZCT': pd.Timedelta('28 days')}


# In[14]:


interesting_patients = ['X', 'Y', 'Z']


# In[112]:


df = ikn_chemo_dict[interesting_patients[0]]
df = df.drop_duplicates()
df['visit_date'] = pd.to_datetime(df['visit_date'])
df = df.sort_values(by='visit_date')
df['prev_visit'] = df['visit_date'].shift()
df.loc[~df['cco_regimen'].eq(df['cco_regimen'].shift()), 'prev_visit'] = pd.NaT # break off when chemo regimen changes
df['chemo_interval'] = df['visit_date'] - df['prev_visit']

# NOTE: for patient X, they have single chemo sessions that gets eliminated. 
# Comment this line out to see what I mean
df = df[~df['chemo_interval'].isnull()] 
df = df.reset_index(drop=True)

df


# In[109]:


# Merges small intervals into a 4 day cycle, or to the row below/above that has interval greater than 4 days
remove_indices = []
for i in range(len(df)):
    if df.loc[i, 'chemo_interval'] > pd.Timedelta('3 days') or pd.isnull(df.loc[i, 'chemo_interval']):
        continue
    if i == len(df)-1 or df.loc[i, 'cco_regimen'] != df.loc[i+1, 'cco_regimen']:
        # merge with the row above if last entry of a regimen
        df.loc[i-1, 'visit_date'] = df.loc[i, 'visit_date']
        df.loc[i-1, 'chemo_interval'] = df.loc[i, 'chemo_interval'] + df.loc[i-1, 'chemo_interval'] 
    else:
        # merge with the row below
        df.loc[i+1, 'prev_visit'] = df.loc[i, 'prev_visit']
        df.loc[i+1, 'chemo_interval'] = df.loc[i, 'chemo_interval'] + df.loc[i+1, 'chemo_interval']
    remove_indices.append(i)
df = df.drop(index=remove_indices)
df


# In[110]:


mask = df['cco_regimen'].eq(df['cco_regimen'].shift()) & (df['chemo_interval'].shift() < pd.Timedelta('60 days'))
group = (mask==False).cumsum()
df['chemo_cycle'] = mask.groupby(group).cumsum()+1
mask = ~df['cco_regimen'].eq(df['cco_regimen'].shift()) &         (df['prev_visit']-df['visit_date'].shift() < pd.Timedelta('60 days'))
mask.iloc[0] = False
df['immediate_new_regimen'] = mask
df


# ## y3 playground

# In[23]:


y3 = pd.read_csv('data/y3.csv')
y3 = y3[y3_cols]
y3['ikn'] = y3['ikn'].str[2:-1].astype(float)
y3 = y3.set_index('ikn')


# In[31]:


neutrophil_df = pd.read_csv('data/neutrophil.csv')
neutrophil_df = neutrophil_df.join(y3, on='ikn')
neutrophil_df['bdate'] = pd.to_datetime(neutrophil_df['bdate'])
neutrophil_df['prev_visit'] = pd.to_datetime(neutrophil_df['prev_visit'])
neutrophil_df['age'] = neutrophil_df['prev_visit'].dt.year - neutrophil_df['bdate'].dt.year


# ### reset curr_morph and curr_topog (replace with 'Other' if less than 6)

# In[ ]:


chemo_df = pd.read_csv('data/chemo_processed.csv')
neutrophil_df = pd.read_csv('data/neutrophil.csv')
platelet_df = pd.read_csv('data/platelet.csv')
hemoglobin_df = pd.read_csv('data/hemoglobin.csv')

neutrophil_df['curr_morph_cd'] = chemo_df['curr_morph_cd']
neutrophil_df['curr_topog_cd'] = chemo_df['curr_topog_cd']
platelet_df['curr_morph_cd'] = chemo_df['curr_morph_cd']
platelet_df['curr_topog_cd'] = chemo_df['curr_topog_cd']
hemoglobin_df['curr_morph_cd'] = chemo_df['curr_morph_cd']
hemoglobin_df['curr_topog_cd'] = chemo_df['curr_topog_cd']

neutrophil_df.to_csv('data/neutrophil.csv',index=False)
platelet_df.to_csv('data/platelet.csv',index=False)
hemoglobin_df.to_csv('data/hemoglobin.csv',index=False)

